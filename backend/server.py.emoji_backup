from flask import Flask, request, jsonify
from flask_cors import CORS
from pyswip import Prolog 
import random
import time
import unicodedata
import re
import sys

# Force UTF-8 encoding for Windows terminals
sys.stdout.reconfigure(encoding='utf-8')

app = Flask(__name__)
CORS(app)

# Init Prolog
prolog = Prolog()
try:
    prolog.consult("backend/knowledge.pl") # Path relative to CWD (root)
    print("âœ“ Knowledge base loaded successfully")
except Exception as e1:
    try:
        prolog.consult("knowledge.pl") # Fallback if running from backend dir
        print("âœ“ Knowledge base loaded successfully (fallback path)")
    except Exception as e2:
        print(f"âŒ CRITICAL: Error loading Prolog knowledge base")
        print(f"   Primary path error: {e1}")
        print(f"   Fallback path error: {e2}")
        raise SystemExit("Cannot start server without knowledge base")

@app.route('/chat', methods=['POST'])
def chat():
    data = request.json
    user_message = data.get('message', '').strip().lower()
    
    # Fonction de sanitization pour Ã©viter l'injection Prolog
    def sanitize_prolog_input(text):
        """Nettoie le texte pour Ã©viter l'injection dans les requÃªtes Prolog"""
        # Remplacer les apostrophes et guillemets dangereux
        text = text.replace("'", " ").replace('"', ' ').replace('\\', ' ')
        # Supprimer les caractÃ¨res de contrÃ´le
        text = ''.join(c for c in text if c.isprintable() or c.isspace())
        return text.strip()
    
    # Normalisation pour gÃ©rer les accents et variations
    def normalize_text(text):
        """Normalise le texte en retirant les accents et en gÃ©rant les variations courantes"""
        # Retirer les accents
        text = ''.join(c for c in unicodedata.normalize('NFD', text) if unicodedata.category(c) != 'Mn')
        # Remplacements courants
        replacements = {
            'medcine': 'medecine',
            'ingenerie': 'ingenierie',
            'ingenieurie': 'ingenierie',
            'informatik': 'informatique',
            'economie': 'eco',
            'litteraire': 'litt',
            'debouche': 'debouches',
            'debouches': 'debouches',
            'metier': 'metiers',
            'metiers': 'metiers',
            'ecole': 'ecoles',
            'ecoles': 'ecoles',
        }
        for old, new in replacements.items():
            text = text.replace(old, new)
        return text
    
    # Normaliser le message utilisateur
    user_message_normalized = normalize_text(user_message)
    
    response_text = "Je n'ai pas compris. Posez une question sur l'orientation (ex: 'Que faire avec un Bac PC ?', 'Conseils rÃ©vision', 'MÃ©decine avec 11 ?')."

    # Helper pour l'encodage (PySwip retourne parfois du Mojibake)
    def clean_text(text):
        if not isinstance(text, str): return str(text)
        cleaned = text
        # 1. Essayer rÃ©paration automatique (Magic Encoding)
        try:
            cleaned = text.encode('cp1252').decode('utf-8')
        except (UnicodeDecodeError, UnicodeEncodeError):
            try:
                cleaned = text.encode('latin-1').decode('utf-8')
            except (UnicodeDecodeError, UnicodeEncodeError):
                pass
        
        # 2. RÃ©paration Manuelle (Fallback si Magic Ã©choue Ã  cause des Emojis)
        # 2. RÃ©paration Manuelle (Fallback si Magic Ã©choue Ã  cause des Emojis)
        # Les emojis font planter l'encode('latin-1'), donc le texte reste cassÃ© (ex: ÃƒÂ©).
        # On force le remplacement des sÃ©quences UTF-8 interprÃ©tÃ©es en Latin-1.
        replacements = {
            'ÃƒÂ©': 'Ã©', 'ÃƒÂ¨': 'Ã¨', 'Ãƒ ': 'Ã ', 'ÃƒÂ¢': 'Ã¢', 'ÃƒÂª': 'Ãª', 'ÃƒÂ®': 'Ã®', 'ÃƒÂ´': 'Ã´', 
            'ÃƒÂ»': 'Ã»', 'ÃƒÂ¹': 'Ã¹', 'ÃƒÂ§': 'Ã§', 'Ã¢â‚¬â„¢': "'", 'Ã…â€œ': 'Å“', 'Ã¢â€šÂ¬': 'â‚¬',
            'Ãƒ\xa0': 'Ã ', 'ÃƒÂ«': 'Ã«', 'ÃƒÂ¯': 'Ã¯', 'Ãƒâ€¦': 'Ã…', 'Ã¢â‚¬Â¦': '...',
            'Ã¢Å¡ Ã¯Â¸': 'âš ï¸', 'Ã¢Å“â€¦': 'âœ…', 'Ã°Å¸â€™Â¡': 'ğŸ’¡', 'Ã°Å¸â€™0': 'ğŸ’°', 
            'Ã¢Å¡ ': 'âš ï¸', 'Ã°Å¸â€œË†': 'ğŸ“ˆ', 'Ã°Å¸â€': 'ğŸ”', 'Ã°Å¸â€˜â€°': 'ğŸ‘‰', 'Ã°Å¸Å’Å¸': 'ğŸŒŸ',
            'Ã°Å¸Å½â€œ': 'ğŸ“', 'Ã°Å¸0': 'ğŸ ', 'Ã°Å¸Â¢': 'ğŸ«', 'Ã°Å¸Â¼': 'ğŸ¨', 'Ã°Å¸Å ': 'ğŸ©º',
            'Ã°Å¸â€º0': 'ğŸ› ï¸', 'Ã°Å¸â€™Â»': 'ğŸ’»', 'Ã°Å¸Å ': 'ğŸ©º', 'Ã°Å¸â€œÅ¡': 'ğŸ“š', 'Ã°Å¸Â¤â€': 'ğŸ¤”'
        }
        for bad, good in replacements.items():
            cleaned = cleaned.replace(bad, good)
            
        # Nettoyage final des artefacts Prolog (guillemets, virgules au dÃ©but/fin)
        cleaned = cleaned.strip().strip("'").strip('"').strip(',').strip()
        
        # Supprimer les crochets '[' ou ']' si prÃ©sents (listes Prolog)
        cleaned = cleaned.replace('[|', '').replace('|]', '').replace('[', '').replace(']', '')
        
        return cleaned

    try:
        # --- ABBREVIATIONS & MOTS COURTS (TrÃ¨s Haute PrioritÃ©) ---
        # CV / Curriculum
        if user_message in ['cv', 'c v', 'curriculum']:
            return jsonify({"response": "Pour crÃ©er un bon CV Ã©tudiant :\n\nğŸ“ **Sections essentielles** :\n- Informations personnelles\n- Formation (Bac, mention)\n- CompÃ©tences (langues, informatique)\n- ExpÃ©riences (stages, projets)\n- Centres d'intÃ©rÃªt\n\nğŸ’¡ **Conseils** :\n- 1 page maximum\n- Police professionnelle\n- Pas de photo (sauf demandÃ©)\n- Mettre en avant les projets acadÃ©miques\n\nBesoin d'aide pour une section spÃ©cifique ?"})
        
        # AbrÃ©viations Ã©coles
        if user_message in ['ensa', 'e n s a']:
            return jsonify({"response": "ğŸ« **ENSA** (Ã‰cole Nationale des Sciences AppliquÃ©es)\n\nÃ‰coles d'ingÃ©nieurs publiques au Maroc.\n\nğŸ“ **Villes** : Rabat, Casa, FÃ¨s, Marrakech, Tanger, Safi, Khouribga, El Jadida, TÃ©touan, Oujda, Agadir, Kenitra.\n\nâœ… **Admission** : Bac PC/SM avec bonne moyenne (13-15+)\nğŸ’° **Frais** : Gratuit (public)\n\nPosez une question plus prÃ©cise (ex: 'ENSA Safi', 'Admission ENSA')"})
        
        if user_message in ['emsi', 'e m s i']:
            return jsonify({"response": "ğŸ« **EMSI** (Ã‰cole Marocaine des Sciences de l'IngÃ©nieur)\n\nÃ‰cole privÃ©e d'ingÃ©nierie et IT.\n\nğŸ“ **Villes** : Rabat, Casa, Marrakech, Tanger\nğŸ’° **Frais** : ~45 000 - 55 000 DH/an\nâœ… **FiliÃ¨res** : Informatique, RÃ©seaux, Data Science, GÃ©nie Civil\n\nPosez une question plus prÃ©cise !"})
        
        # Langues courtes
        if user_message in ['fr', 'franÃ§ais', 'francais']:
            return jsonify({"response": "ğŸ‡«ğŸ‡· **Ã‰tudes en FranÃ§ais**\n\nLe franÃ§ais est la langue principale pour :\nâœ… Sciences et techniques\nâœ… MÃ©decine\nâœ… IngÃ©nierie\nâœ… Commerce\n\nRecommandÃ© si niveau â‰¥ B2.\n\nPosez 'Langue franÃ§ais' pour plus de dÃ©tails."})
        
        if user_message in ['en', 'anglais', 'english']:
            return jsonify({"response": "ğŸ‡¬ğŸ‡§ **Ã‰tudes en Anglais**\n\nL'anglais est utilisÃ© pour :\nâœ… IT et Data Science\nâœ… Business international\nâœ… Programmes internationaux\n\nNiveau B2/C1 requis.\n\nPosez 'Langue anglais' pour plus de dÃ©tails."})
        
        if user_message in ['ar', 'arabe']:
            return jsonify({"response": "ğŸ‡²ğŸ‡¦ **Ã‰tudes en Arabe**\n\nL'arabe est utilisÃ© pour :\nâœ… Lettres et sciences humaines\nâœ… Droit national\nâœ… Sciences islamiques\n\nPosez 'Langue arabe' pour plus de dÃ©tails."})

        # --- SALUTATIONS MULTILINGUES (PrioritÃ© Haute) ---
        # FranÃ§ais
        if user_message in ['bonjour', 'bjr', 'bonsoir', 'bsr']:
            greetings = [
                "Bonjour ! ğŸ‘‹ Comment puis-je vous aider avec votre orientation ?",
                "Bonjour ! ğŸ“ Posez-moi vos questions sur l'orientation post-bac.",
                "Bonsoir ! Comment s'est passÃ©e votre journÃ©e ? Je suis lÃ  pour vous aider."
            ]
            return jsonify({"response": random.choice(greetings)})
        
        if user_message in ['salut', 'slt', 'coucou', 'cc']:
             return jsonify({"response": "Salut ! ğŸ‘‹ Ã‡a va ? Besoin d'aide pour ton orientation ?"})
        
        if user_message in ['ca va', 'Ã§a va', 'comment ca va', 'comment Ã§a va', 'labas', 'kidayr']:
             return jsonify({"response": "Je vais trÃ¨s bien, merci ! ğŸ¤– Toujours prÃªt pour vous orienter. Et vous ?"})
        
        if user_message in ['hey', 'yo']:
            return jsonify({"response": "Hey ! ğŸ˜Š Quoi de neuf ? Des questions sur tes Ã©tudes ?"})
        
        if 'bonjour monsieur' in user_message or 'bonjour madame' in user_message:
            return jsonify({"response": "Bonjour Monsieur/Madame ! Comment puis-je vous aider aujourd'hui ?"})
        
        if 'bonjour professeur' in user_message:
            return jsonify({"response": "Bonjour Professeur ! ğŸ“"})
        
        # Darija (Arabe Marocain)
        if user_message in ['salam', 'salam alaykom', 'salam 3likom']:
            return jsonify({"response": "Salam ! ğŸ‘‹ Labas 3lik ? Kifach n9der n3awnek ?"})
        
        if 'sb7 lkhir' in user_message or 'sbah lkhir' in user_message:
            return jsonify({"response": "Sb7 lkhir ! â˜€ï¸ Labas ? Chno bghiti t3raf 3la l9raya ?"})
        
        if 'msa lkhir' in user_message or 'msa2 lkhir' in user_message:
            return jsonify({"response": "Msa lkhir ! ğŸŒ™ Kidayra nhark ? Wash 3andek chi so2al ?"})
        
        if 'choukran' in user_message or 'chokran' in user_message:
            return jsonify({"response": "Marhba bik ! ğŸ˜Š Wakha ghir so2el."})
        
        # Anglais
        if user_message in ['hello', 'hi', 'hey there']:
            return jsonify({"response": "Hello! ğŸ‘‹ How can I help you with your studies today?"})
        
        if 'good morning' in user_message:
            return jsonify({"response": "Good morning! â˜€ï¸ How can I assist you?"})
        
        if 'good evening' in user_message:
            return jsonify({"response": "Good evening! ğŸŒ™ How's your day going?"})

        # --- QUESTIONS META SUR LE CHATBOT ---
        # YAFI Definition (TRES HAUTE PRIORITE)
        if any(keyword in user_message for keyword in ['yafi', 'y.a.f.i', 'y a f i']):
            return jsonify({"response": "âœ¨ **YAFI** est un acronyme formÃ© Ã  partir des prÃ©noms des crÃ©ateurs du projet :\n\nğŸ‘¤ **Y** â†’ Yasser\nğŸ‘¤ **A** â†’ Adam\nğŸ‘¤ **F** â†’ Fahd\nğŸ§  **I** â†’ Intelligence\n\nğŸ‘‰ **I = Intelligence**, en rÃ©fÃ©rence Ã  :\n- ğŸ¤– L'intelligence artificielle\n- ğŸ§­ L'intelligence d'orientation\n- ğŸ’¡ L'aide intelligente Ã  la dÃ©cision post-bac"})

        # IdentitÃ© et rÃ´le
        if any(keyword in user_message for keyword in ['qui es-tu', 'qui es tu', 'quel est ton role', 'quel est ton roll', 'ton role', 'ton roll', 'tu fais quoi', 'ton but', 'c\'est quoi ce bot', 'c\'est quoi ce site', 'c\'est quoi cette app']):
            return jsonify({"response": "Je suis un chatbot d'orientation post-bac pour les Ã©tudiants marocains ! ğŸ“\n\nMon rÃ´le est de vous aider Ã  :\nâœ… Choisir votre filiÃ¨re selon votre Bac\nâœ… Trouver les bonnes Ã©coles (publiques/privÃ©es)\nâœ… Comprendre les stratÃ©gies d'admission\n\nğŸ’¡ **Bon Ã  savoir** : Vous pouvez m'Ã©crire **sans accents** et sans vous soucier des caractÃ¨res complexes (ex: 'medecine', 'ingenieur'). Je vous comprendrai parfaitement !"})
        
        # CrÃ©ateur
        if any(keyword in user_message for keyword in ['qui t\'a cree', 'qui t\'a crÃ©Ã©', 'qui a cree', 'qui a crÃ©Ã©', 'adam moufrije', 'ton createur', 'ton crÃ©ateur', 'le createur', 'le crÃ©ateur', 'son createur', 'son crÃ©ateur', 'qui t a fait', 'qui t\'a fait', 'ton developpeur', 'ton dÃ©veloppeur', 'qui a developpe', 'qui a dÃ©veloppÃ©']):
            return jsonify({"response": "ğŸ‘¨â€ğŸ’» Le crÃ©ateur et dÃ©veloppeur de ce modÃ¨le et de la base de connaissances est **Adam Moufrije**.\n\nğŸš€ Ce projet a Ã©tÃ© rÃ©alisÃ© avec le soutien de diffÃ©rents **LLMs** (Large Language Models) pour aider Ã  la crÃ©ation et au dÃ©veloppement du systÃ¨me."})
        
        # Nature (AI/Bot)
        if any(keyword in user_message for keyword in ['tu es un ai', 'tu est un ai', 'tu es une ia', 'tu est une ia', 'es-tu un robot', 'es-tu un bot', 'est-tu un robot', 'chatbot', 'robot']):
            return jsonify({"response": "Oui, je suis un chatbot intelligent (IA) ! ğŸ¤–\n\nJe combine :\n- **Prolog** pour la logique d'orientation\n- **Python** pour le traitement\n- **React** pour l'interface\n\nJe suis spÃ©cialisÃ© dans l'orientation post-bac au Maroc. Posez-moi vos questions !"})
        
        # Remerciements / Feedback
        if any(keyword in user_message for keyword in ['merci', 'thank you', 'thanks', 'Ø´ÙƒØ±Ø§']):
            return jsonify({"response": "De rien ! ğŸ˜Š Je suis lÃ  pour vous aider.\n\nN'hÃ©sitez pas si vous avez d'autres questions sur votre orientation ! ğŸ“"})
        
        # Plaintes / Erreurs
        if any(keyword in user_message for keyword in ['arret', 'arrÃªte', 'stop', 'meme reponse', 'mÃªme rÃ©ponse', 'bug', 'erreur']):
            return jsonify({"response": "DÃ©solÃ© si ma rÃ©ponse n'Ã©tait pas claire ! ğŸ˜…\n\nEssayez de reformuler votre question de maniÃ¨re plus prÃ©cise, par exemple :\n- 'Que faire avec un Bac PC ?'\n- 'MÃ©decine avec 13 de moyenne'\n- 'Prix EMSI'\n- 'DÃ©bouchÃ©s informatique'\n\nJe suis lÃ  pour vous aider ! ğŸ’ª"})

        # --- 4. INFOS PRATIQUES (Prioritaire) ---
        
        # 4.1. Seuils & Dates
        if "seuil" in user_message or "date" in user_message or ("quand" in user_message and ("concours" in user_message or "inscription" in user_message)):
             keywords_map = {
                 'ensa': 'Concours ENSA', 'encg': 'Concours ENCG (TAFEM)', 'medecine': 'Concours Medecine', 'mÃ©decine': 'Concours Medecine',
                 'fst': 'Inscription CursusSup', 'est': 'Inscription CursusSup', 'cursussup': 'Inscription CursusSup', 'ofppt': 'Inscription OFPPT',
                 'bac': 'Resultats Bac'
             }
             found = None
             for k, v in keywords_map.items():
                 if k in user_message: found = v; break
            
             if found:
                 q_date = f"get_date_concours('{found}', D)"
                 res_d = list(prolog.query(q_date))
                 date_txt = clean_text(res_d[0]['D']) if res_d else "Non dÃ©fini"
                 
                 seuil_txt = ""
                 if "ENSA" in found: school="ENSA"
                 elif "ENCG" in found: school="ENCG"
                 elif "Medecine" in found: school="Medecine"
                 elif "FST" in user_message.upper(): school="FST"
                 elif "EST" in user_message.upper(): school="EST"
                 else: school=None
                 
                 if school:
                     q_seuil = f"get_seuil('{school}', 2023, N)"
                     res_s = list(prolog.query(q_seuil))
                     if res_s: seuil_txt = f"\nğŸ“‰ **Seuil 2023** : {clean_text(res_s[0]['N'])}/20"
                 
                 return jsonify({"response": f"ğŸ“… **{found}** :\nğŸ—“ï¸ **Date** : {date_txt}{seuil_txt}"})
             else:
                 return jsonify({"response": "ğŸ“… **Calendrier** : Je connais les dates pour ENSA, ENCG, MÃ©decine, CursusSup..."})

        # 4.2. Liens & Sites
        if "lien" in user_message or "site" in user_message or "adresse" in user_message:
             keys = {'cursussup': 'CursusSup', 'minhaty': 'Minhaty (Bourse)', 'ensa': 'ENSA Maroc', 'tafem': 'TAFEM (ENCG)', 'ofppt': 'OFPPT'}
             found = None
             for k, v in keys.items():
                 if k in user_message: found = v; break
             
             if found:
                 q = f"get_lien('{found}', U)"
                 res = list(prolog.query(q))
                 url = clean_text(res[0]['U']) if res else "#"
                 return jsonify({"response": f"ğŸ”— **Lien {found}** : [Cliquez ici]({url})"})
             else:
                 return jsonify({"response": "ğŸ”— **Liens Utiles** : Demandez-moi CursusSup, Minhaty, ENSA..."})

        # 4.3. ProcÃ©dures & Logement
        if "dÃ©marche" in user_message or "procÃ©dure" in user_message or "dossier" in user_message or "inscription" in user_message or "s'inscrire" in user_message or "papier" in user_message or "document" in user_message or "logement" in user_message or "citÃ©" in user_message or "internat" in user_message:
            # Check Logement
            if "logement" in user_message or "citÃ©" in user_message or "internat" in user_message:
                type_log = 'Cite Universitaire'
                if "privÃ©" in user_message or "location" in user_message: type_log = 'Location Privee'
                elif "internat" in user_message: type_log = 'Internat'
                
                q = f"get_logement('{type_log}', D, C)"
                res = list(prolog.query(q))
                if res:
                     return jsonify({"response": f"ğŸ  **{type_log}** :\nâ„¹ï¸ {clean_text(res[0]['D'])}\nğŸ’¡ {clean_text(res[0]['C'])}"})
                else:
                     return jsonify({"response": "ğŸ  **Logement** : PrÃ©cisez CitÃ©, Internat ou Location."})
            else:
                # ProcÃ©dures
                proc = 'Inscription Fac' # Default
                if "minhaty" in user_message or "bourse" in user_message: proc = 'Dossier Minhaty'
                elif "legalis" in user_message: proc = 'Legalisation'
                
                q = f"get_procedure('{proc}', D)"
                res = list(prolog.query(q))
                if res:
                     return jsonify({"response": f"ğŸ“ **ProcÃ©dure {proc}** :\n{clean_text(res[0]['D'])}"})

        # 4.4. OFPPT
        if "ofppt" in user_message or "technicien" in user_message or "ista" in user_message:
             niveau = 'Technicien Specialise'
             if "qualif" in user_message: niveau = 'Qualification'
             elif "technicien" in user_message and "spÃ©cialisÃ©" not in user_message: niveau = 'Technicien'
             
             q = f"get_formation_pro('{niveau}', D, C)"
             res = list(prolog.query(q))
             if res:
                  return jsonify({"response": f"ğŸ­ **OFPPT ({niveau})** :\nâ„¹ï¸ {clean_text(res[0]['D'])}\nğŸ’¡ {clean_text(res[0]['C'])}"})

        # 4.5. Calculateur de Note
        # 4.5. Calculateur de Note & Orientation par Moyenne
        # DÃ©tection de nombres (Note 0-20)
        nums = re.findall(r'\d+(?:[.,]\d+)?', user_message)
        nums = [float(n.replace(',', '.')) for n in nums]
        valid_grades = [n for n in nums if n <= 20]

        is_calc_request = "calcul" in user_message or "score" in user_message
        is_grade_context = "moyenne" in user_message or "bac" in user_message or "j'ai" in user_message or "note" in user_message

        if (is_calc_request or is_grade_context) and valid_grades:
             
             # CAS A : CALCULATEUR (2 notes : RÃ©gional + National)
             if len(valid_grades) >= 2:
                  reg = valid_grades[0]
                  nat = valid_grades[1]
                  score = (reg * 0.25) + (nat * 0.75)
                  resp = f"ğŸ§® **Calculateur de Seuil** :\n- RÃ©gional (25%) : {reg}\n- National (75%) : {nat}\n\nâœ¨ **Votre Score d'Admission : {score:.2f}/20**\n"
                  
                  if score >= 15: resp += "ğŸŒŸ Excellent ! Vous Ãªtes bien parti pour MÃ©decine/ENSA."
                  elif score >= 12: resp += "âœ… Bon score. FST et EST sont trÃ¨s jouables. ENSA possible (vÃ©rifiez seuils)."
                  else: resp += "âš ï¸ Un peu juste pour les filiÃ¨res sÃ©lectives. Visez EST, BTS ou Fac."
                  return jsonify({"response": resp})
             
             # CAS B : CONSEIL ORIENTATION (1 note donnÃ©e)
             elif len(valid_grades) == 1:
                  note = valid_grades[0]
                  
                  # Detect Bac
                  bac = 'SVT' # Par dÃ©faut
                  if 'pc' in user_message: bac = 'PC'
                  elif 'sm' in user_message: bac = 'SM'
                  elif 'eco' in user_message: bac = 'ECO'
                  elif 'litt' in user_message: bac = 'LITT'
                  elif 'tech' in user_message: bac = 'TECH'
                  
                  q = f"strategie_profil({note}, '{bac}', Conseil)"
                  res = list(prolog.query(q))
                  if res:
                       return jsonify({"response": f"ğŸ¯ **Conseil Orientation (Note : {note}/20)** :\n{clean_text(res[0]['Conseil'])}"})
                  else:
                       return jsonify({"response": f"Avec {note}/20, vous avez plusieurs options. PrÃ©cisez votre Bac pour un conseil ciblÃ© !"})

        if "calcul" in user_message and not valid_grades:
             return jsonify({"response": "ğŸ§® **Calculateur** : Donnez-moi vos notes RÃ©gional et National (ex: 'Calcul 14 16') pour avoir votre score."})

        # 4.6. Quiz Orientation
        if "quiz" in user_message or "aime" in user_message or "prÃ©fÃ¨re" in user_message or "fort en" in user_message:
             scores = {'ingenierie': 0, 'medecine': 0, 'commerce': 0, 'lettres': 0, 'art': 0}
             
             if "math" in user_message: scores['ingenierie'] += 2; scores['commerce'] += 1
             if "physique" in user_message: scores['ingenierie'] += 2
             if "svt" in user_message or "bio" in user_message: scores['medecine'] += 3
             if "info" in user_message or "cod" in user_message: scores['ingenierie'] += 2
             if "eco" in user_message or "gest" in user_message: scores['commerce'] += 3
             if "langue" in user_message or "fran" in user_message: scores['lettres'] += 2; scores['commerce'] += 1
             if "dessin" in user_message or "art" in user_message: scores['art'] += 3; scores['ingenierie'] += 1
             
             best = max(scores, key=scores.get)
             resp = "ğŸ§  **Quiz Orientation** :\n"
             if scores[best] > 0:
                 if best == 'ingenierie': rec = "Vous semblez avoir un profil **IngÃ©nieur / Tech** ! ğŸ› ï¸\nğŸ‘‰ Visez ENSA, CPGE, FST, EST."
                 elif best == 'medecine': rec = "Vous avez un profil **SantÃ© / Bio** ! ğŸ©º\nğŸ‘‰ Visez MÃ©decine, Pharmacie, ISPITS."
                 elif best == 'commerce': rec = "Vous avez un profil **Manager / Eco** ! ğŸ’¼\nğŸ‘‰ Visez ENCG, ISCAE, EST."
                 elif best == 'lettres': rec = "Vous avez un profil **LittÃ©raire / Droit** ! ğŸ“š\nğŸ‘‰ Visez Fac de Droit, Lettres, Journalisme."
                 elif best == 'art': rec = "Vous avez un profil **CrÃ©atif / Archi** ! ğŸ¨\nğŸ‘‰ Visez ENA (Archi), Beaux-Arts ou Design."
                 
                 resp += rec + "\n\n(Dites 'DÃ©tail IngÃ©nieur' pour en savoir plus)"
             else:
                 resp += "Dites-moi quelles matiÃ¨res vous aimez (Maths, SVT, Eco, Langues...) pour que je vous oriente !"
             return jsonify({"response": resp})
        
        # Critiques / Insultes (rÃ©ponse calme)
        if any(keyword in user_message for keyword in ['nul', 'null', 'mauvais', 'pas bon', 'debile', 'bÃªte', 'idiot']):
            return jsonify({"response": "Je suis dÃ©solÃ© si je n'ai pas rÃ©pondu Ã  vos attentes. ğŸ˜”\n\nPour mieux vous aider, posez une question prÃ©cise comme :\n- 'Bac PC que faire ?'\n- 'Prix Ã©cole privÃ©e'\n- 'Conseils rÃ©vision'\n\nJe ferai de mon mieux ! ğŸ’ª"})

        # --- 1. STATISTIQUES & CHIFFRES (PrioritÃ© Haute) ---
        if "place" in user_message or "combien" in user_message or "nombre" in user_message or "stat" in user_message or "chance" in user_message or "monde" in user_message:
            
            keywords = ['mÃ©decine', 'ensa', 'encg', 'ensam', 'fst', 'global', 'casa', 'rabat', 'agadir', 'salaire']
            found_key = next((k for k in keywords if k in user_message), None)
            
            if found_key:
                stats = list(prolog.query("stat(Cat, Entite, Val)"))
                matches = []
                for s in stats:
                    if found_key.lower() in str(s['Entite']).lower():
                        matches.append(s)
                
                if matches:
                     response_text = f"ğŸ“Š **Statistiques pour '{found_key.capitalize()}' :**\n"
                     for m in matches:
                         val_clean = clean_text(m['Val'])
                         cat_clean = clean_text(m['Cat'])
                         entite_clean = clean_text(m['Entite'])
                         response_text += f"- {cat_clean} ({entite_clean}) : **{val_clean}**\n"
                else:
                    response_text = f"Je n'ai pas de chiffre prÃ©cis pour '{found_key}'."
            else:
                 response_text = "ğŸ“Š **Le Saviez-vous ?**\n- Il y a 1.25 million d'Ã©tudiants au Maroc.\n- La sÃ©lectivitÃ© est rude : 1 place pour 22 candidats en MÃ©decine !"

        # --- 2. GEOGRAPHIE & VILLES (PrioritÃ© Haute) ---- Inclut Ville Chance
        elif ("oÃ¹" in user_message or "ville" in user_message or "trouve" in user_message or "localisation" in user_message or "campus" in user_message or "Ã©cole" in user_message or "ecole" in user_message or "universitÃ©" in user_message or "concurrence" in user_message or "chance" in user_message or "opportunitÃ©" in user_message or any(v in user_message for v in ['rabat', 'casa', 'marrakech', 'agadir', 'fÃ¨s', 'meknÃ¨s', 'tanger', 'oujda', 'safi', 'khouribga', 'el jadida', 'tetouan'])) and not "avantage" in user_message and not "inconvÃ©nient" in user_message:
            
            # CAS 0 : RECHERCHE VILLE CHANCE / CONCURRENCE
            if "concurrence" in user_message or "chance" in user_message or "opportunitÃ©" in user_message or "moins de" in user_message:
                 chances_q = list(prolog.query("ville_chance(V)"))
                 villes_list = [clean_text(c['V']) for c in chances_q]
                 response_text = "ğŸŒ **Villes 'OpportunitÃ©' (Moins de concurrence)** :\n"
                 response_text += "Voici les villes oÃ¹ le ratio Places/Candidats est souvent plus favorable (bon plan pour les listes d'attente !) :\n"
                 for v in villes_list:
                     response_text += f"- ğŸ™ï¸ {v}\n"
                 response_text += "\nğŸ’¡ **Conseil** : Pensez Ã  y postuler (FST, ENSA, EST) mÃªme si vous visez les grandes villes."
            
            else:
                # Cas 1 : User cherche oÃ¹ se trouve une Ã©cole (ex: "OÃ¹ est l'ENSA ?")
                ecoles_cles = ['ensa', 'ensam', 'ensias', 'encg', 'fst', 'est', 'um6p', 'universite', 'emsi', 'uir', 'hem']
                ecole_demandee = next((e for e in ecoles_cles if e in user_message), None)
            
                # On distingue "OÃ¹ est ecole" de "Ecoles Ã  Ville"
                # Si on a un nom de ville explicite, on priorise la recherche par ville
                villes_cles = ['rabat', 'casa', 'casablanca', 'marrakech', 'agadir', 'fÃ¨s', 'fes', 'meknÃ¨s', 'meknes', 'tanger', 'oujda', 'safi', 'khouribga', 'beni mellal', 'el jadida', 'taza', 'errachidia', 'kÃ©nitra', 'kenitra', 'mohammedia', 'settat', 'berrechid', 'dakhla', 'laayoune', 'nador', 'al hoceima', 'tetouan', 'tÃ©touan']
                ville_demandee = next((v for v in villes_cles if v in user_message), None)

                if ville_demandee and not ("oÃ¹ est" in user_message or "trouve" in user_message):
                     # Cas 2 : User demande ce qu'il y a dans une VILLE (ex: "Ecoles Ã  Rabat")
                     locs = list(prolog.query("localisation(Ecole, Ville)"))
                     found_ecoles = []
                     for l in locs:
                         ville_p = clean_text(l['Ville'])
                         if ville_demandee.lower() in ville_p.lower():
                              found_ecoles.append(clean_text(l['Ecole']))
                     
                     # NEW: Search in etablissement/5 as well
                     try:
                         etabs_loc = list(prolog.query(f"etablissement(Nom, '{ville_demandee.capitalize()}', _, _, _)"))
                         # Try loose match if exact fail
                         if not etabs_loc:
                             etabs_loc = list(prolog.query("etablissement(Nom, Ville, _, _, _)"))
                             etabs_loc = [e for e in etabs_loc if ville_demandee.lower() in clean_text(e['Ville']).lower()]
                             
                         for e in etabs_loc:
                             name = clean_text(e['Nom'])
                             if name not in found_ecoles: found_ecoles.append(name)
                     except: pass

                     chance_msg = ""
                     chances = list(prolog.query("ville_chance(V)"))
                     for c in chances:
                         vc = clean_text(c['V'])
                         if ville_demandee.lower() in vc.lower():
                             chance_msg = "\nâœ… **Note:** Ville 'OpportunitÃ©' (Moins de concurrence, bon plan !)."

                     if found_ecoles:
                         response_text = f"ğŸ« Ã€ **{ville_demandee.capitalize()}**, vous trouverez :\n" + "\n".join([f"- {e}" for e in sorted(list(set(found_ecoles)))]) + chance_msg
                     else:
                         response_text = f"Je n'ai pas d'info spÃ©cifique sur les Ã©coles Ã  {ville_demandee}."
                
                elif ecole_demandee:
                    ecole_upper = ecole_demandee.upper()
                    if ecole_demandee == 'universite': ecole_upper = 'UniversitÃ©'
                    
                    found_villes = []
                    
                    # Check Localisation (Old)
                    locs = list(prolog.query("localisation(Ecole, Ville)"))
                    for l in locs:
                         if ecole_demandee.lower() in str(l['Ecole']).lower():
                            v = clean_text(l['Ville'])
                            found_villes.append(v)
                    
                    # Check Etablissement (New)
                    try:
                        all_etabs = list(prolog.query("etablissement(Nom, Ville, _, _, _)"))
                        for e in all_etabs:
                            nom = clean_text(e['Nom']).lower()
                            if ecole_demandee.lower() in nom or nom in ecole_demandee.lower():
                                 v = clean_text(e['Ville'])
                                 if v not in found_villes:
                                     found_villes.append(v)
                    except:
                        pass
    
                    # FILTER BY CITY IF SPECIFIED (e.g. "OÃ¹ est l'ENSA KÃ©nitra ?")
                    if ville_demandee:
                        filtered = [v for v in found_villes if ville_demandee.lower() in v.lower()]
                        if filtered:
                            response_text = f"ğŸ“ **{ecole_upper}** est bien prÃ©sent Ã  **{filtered[0]}**."
                        else:
                            response_text = f"ğŸ“ **{ecole_upper}** ne semble pas Ãªtre Ã  {ville_demandee.capitalize()} (ou je ne l'ai pas dans ma base).\nVoici oÃ¹ le trouver : {', '.join(sorted(list(set(found_villes))))}"
                    
                    elif found_villes:
                        unique_villes = sorted(list(set(found_villes)))
                        response_text = f"ğŸ“ **{ecole_demandee.upper()}** est prÃ©sent Ã  :\n" + ", ".join(unique_villes)
                    else:
                        response_text = f"DÃ©solÃ©, je ne trouve pas la localisation pour '{ecole_demandee}'."
                else:
                     response_text = "ğŸŒ Je peux vous dire oÃ¹ se trouvent les Ã©coles ou ce qu'il y a dans votre ville."


        # --- 3. STRATEGIE & TYPES ETABLISSEMENTS ---
        # --- 3. STRATEGIE & TYPES ETABLISSEMENTS ---
        elif "stratÃ©gie" in user_message or "avantage" in user_message or "inconvÃ©nient" in user_message or "ouvert" in user_message or "rÃ©gulÃ©" in user_message or "type" in user_message:
             
             # A. PROS / CONS Types
             types_map = {
                 'public_ouvert': ['fac', 'ouverte', 'ouvert', 'universitÃ©', 'droit', 'eco', 'sans sÃ©lection', 'open', 'public', 'publique'],
                 'public_regule': ['rÃ©gulÃ©e', 'rÃ©gulÃ©', 'regule', 'ensa', 'mÃ©decine', 'prepa', 'concours', 'public sÃ©lectif'],
                 'prive': ['privÃ©', 'prive', 'payant', 'supinfo', 'uir', 'emsi', 'ecole payante']
             }
             found_type = next((k for k, v in types_map.items() if any(sub in user_message for sub in v)), None)
            
             # PrioritÃ© aux questions sur les avantages/inconvÃ©nients ou dÃ©finitions de types
             if ("avantage" in user_message or "inconvÃ©nient" in user_message or "c'est quoi" in user_message or "type" in user_message) and found_type:
                  # Note: found_type is now an atom string like 'public_ouvert'
                  q = f"get_info_type({found_type}, Desc, Av, Inc)"
                  res = list(prolog.query(q))
                  if res:
                      r = res[0]
                      # Clean type name for display
                      display_name = found_type.replace('_', ' ').replace('regule', 'rÃ©gulÃ©').title()
                      response_text = f"ğŸ« **{display_name}** :\nğŸ“Œ {clean_text(r['Desc'])}\n{clean_text(r['Av'])}\n{clean_text(r['Inc'])}"
                  else:
                      response_text = f"Je n'ai pas d'infos dÃ©taillÃ©es sur le type '{found_type}'."

             # B. STRATEGIE PERSO (Note + Bac ?)
             elif "stratÃ©gie" in user_message or "conseil" in user_message:

                 match = re.search(r'\b(1[0-9]|20|[0-9])(\.[0-9]+)?\b', user_message) # Float support
                 
                 if match:
                     note = float(match.group(0))
                     
                     # Detect Bac
                     bac = 'SVT' # Default
                     if 'pc' in user_message: bac = 'PC'
                     elif 'sm' in user_message: bac = 'SM'
                     elif 'eco' in user_message: bac = 'ECO'
                     
                     q = f"strategie_profil({note}, '{bac}', Conseil)"
                     res = list(prolog.query(q))
                     if res:
                         response_text = f"ğŸ¯ **StratÃ©gie Orientation ({note}/20 - Bac {bac})** :\n{clean_text(res[0]['Conseil'])}"
                     else:
                         response_text = "Pas de conseil spÃ©cifique pour ce cas exact."
                 else:
                     if "stratÃ©gie" in user_message:
                        response_text = "Pour une stratÃ©gie personnalisÃ©e, donnez-moi votre moyenne (ex: 'StratÃ©gie avec 14')."
                     else:
                        # Fallback to generic conseil if no note
                        pass # Let it fall through to generic Conseil block?
                        # No, if we are in this ELIF, we are trapped. 
                        # We must provide response OR use 'continue' logic which Flask doesn't have easily.
                        # So I should handle "Conseil" without note here or return "Je ne sais pas".
                        # But "Conseil" general is handled below. 
                        # I should only trap "Strategy" here.
                        response_text = "Pour une stratÃ©gie personnalisÃ©e, donnez-moi votre moyenne (ex: 'StratÃ©gie avec 14')."

             if not response_text: # Fallback if B failed to produce text (e.g. "conseil" matched but no note)
                  # If we captured "conseil" here but didn't have a note, we might want to let the Generic Conseil block handle it.
                  # But we can't 'break' to next elif.
                  # So I strictly limit B to "stratÃ©gie".
                  pass 
             
             # Re-refining B condition:
             # Only trap if "stratÃ©gie" is present.
             # If "conseil", let it go to Generic Conseil block?
             # But "stratÃ©gie" keywords triggered the outer block.
             # So we must handle it.
             
             if not ('response_text' in locals() and response_text):
                 response_text = "Je peux comparer les filiÃ¨res (Ouvertes vs RÃ©gulÃ©es) ou vous donner une stratÃ©gie selon votre note."
        
        # --- 6. ECOLES PRIVEES & FRAIS & PUBLIC (Prix) ---
        elif "prix" in user_message or "frais" in user_message or "coÃ»t" in user_message or "payer" in user_message or "privÃ©" in user_message or "gratuit" in user_message or "emsi" in user_message or "uir" in user_message or "hem" in user_message or "esca" in user_message or ("ensa" in user_message and ("frais" in user_message or "prix" in user_message or "gratuit" in user_message)):
             
             # A. Check Ecoles Publiques (Gratuites)
             ecoles_publiques = ['ensa', 'ensam', 'ensias', 'encg', 'fst', 'est', 'universite', 'facultÃ©', 'mÃ©decine']
             public_found = next((e for e in ecoles_publiques if e in user_message), None)
             
             # B. Check Ecoles PrivÃ©es
             ecoles_privees = ['emsi', 'uir', 'supinfo', 'emg', 'hem', 'esca', 'uiass', 'upsat', 'isitt']
             priv_found = next((e for e in ecoles_privees if e in user_message), None)

             if public_found and not priv_found:
                 response_text = f"ğŸ›ï¸ **{public_found.upper()}** est un Ã©tablissement **Public**.\nâœ… **Les frais de scolaritÃ© sont GRATUITS** (0 DH).\nIl faut juste payer les frais d'inscription annuels (~200 DH) et l'assurance."

             elif priv_found:
                 # Limitation: Ne pas repondre aux questions "Qui est le directeur" avec les frais
                 if "directeur" in user_message or "prÃ©sident" in user_message:
                     response_text = f"Je n'ai pas l'information sur le directeur de {priv_found.upper()}. Je peux par contre vous donner les frais et spÃ©cialitÃ©s."
                 else:
                     details = list(prolog.query("detail_ecole(Nom, Cat, Spec, Frais)"))
                     match = next((d for d in details if priv_found.lower() in str(d['Nom']).lower()), None)
                     
                     if match:
                         response_text = f"ğŸ’ **{clean_text(match['Nom'])}** ({clean_text(match['Cat'])})\n"
                         response_text += f"- ğŸ’° **Frais**: {clean_text(match['Frais'])}\n"
                         response_text += f"- ğŸ“ **SpÃ©cialitÃ©s**: {clean_text(match['Spec'])}\n"
                     else:
                         response_text = f"DÃ©tails financiers non trouvÃ©s pour {priv_found}."
             else:
                 response_text = "ğŸ’° **Enseignement PrivÃ©** : EMSI (~35k/an), UIR (~80k/an), Medecine PrivÃ©e (~100k/an)...\nğŸ›ï¸ **Public** : Gratuit."

        # --- 4. DEFINITIONS & SYSTEME ---
        elif "c'est quoi" in user_message or "systÃ¨me" in user_message or "diplÃ´me" in user_message or "lmd" in user_message or "master" in user_message or "licence" in user_message or "doctorat" in user_message or "bts" in user_message or "dut" in user_message or "cpge" in user_message:
            
            termes = ['lmd', 'licence', 'master', 'doctorat', 'bts', 'dut', 'ingÃ©nieur', 'cpge']
            terme_found = next((t for t in termes if t in user_message), None)
            
            if terme_found:
                defs = list(prolog.query("definition(Terme, Def)"))
                match = next((d for d in defs if terme_found.lower() in str(d['Terme']).lower()), None)
                
                if match:
                    response_text = f"ğŸ“– **{clean_text(match['Terme'])}** :\n{clean_text(match['Def'])}"
                else:
                    response_text = f"DÃ©finition non trouvÃ©e pour {terme_found}."
            else:
                 response_text = "ğŸ“š **SystÃ¨me LMD** : Licence (3 ans), Master (5 ans), Doctorat (8 ans)."

        # --- 5. MEDECINE (Test de note & CompatibilitÃ©) ---
        # --- 5. COMPATIBILITE (Generalise: Medecine, Ecng, Ingenerie, etc.) ---
        elif ("mÃ©decine" in user_message or "medecine" in user_message or "ingÃ©nieur" in user_message or "ingenieur" in user_message or "encg" in user_message or "informatique" in user_message) and ("bac" in user_message or "avec" in user_message or "peut" in user_message):
            
            # 1. Detecter le BAC

            bacs_map = {
                'SM': [r'\bsm\b', r'\bmath\b', r'\bmaths\b'],
                'PC': [r'\bpc\b', r'\bphysique\b'],
                'SVT': [r'\bsvt\b', r'\bscience vie\b', r'\bbio\b'],
                'ECO': [r'\beco\b', r'\beconomie\b', r'\bgestion\b'],
                'LITT': [r'\blitt\b', r'\blettre\b', r'\blettres\b'],
                'TECH': [r'\btech\b', r'\belec\b', r'\bmeca\b']
            }
            detected_bac = 'SVT' # Default fallback if only target is mentioned, often users imply SVT/PC logic? No, risky. 
            # Better to try to find it.
            found_b = None
            for code, keywords in bacs_map.items():
                for pat in keywords:
                    if re.search(pat, user_message, re.IGNORECASE):
                        found_b = code
                        break
                if found_b: break
            
            # 2. Detecter la FILIERE CIBLE
            targets_map = {
                'medecine': [r'm[Ã©e]decine', r'pharmacie', r'dentaire', r'sant[Ã©]'],
                'ingenierie': [r'ing[Ã©e]nieur', r'ing[Ã©e]nierie', r'g[Ã©e]nie', r'ensa', r'emi'],
                'commerce': [r'commerce', r'gestion', r'encg', r'iscae', r'marketing'],
                'informatique': [r'info', r'informatique', r'dev', r'programmation'],
                'lettres': [r'droit', r'lettre', r'juridique']
            }
            detected_target = None
            for t_code, keywords in targets_map.items():
                for pat in keywords:
                    if re.search(pat, user_message, re.IGNORECASE):
                        detected_target = t_code
                        break
                if detected_target: break
            
            # 3. Logique
            if found_b and detected_target:
                # On a les deux : Check CompatibilitÃ©
                q_compat = f"check_compatibilite('{found_b}', {detected_target}, Statut, Msg)"
                compat_res = list(prolog.query(q_compat))
                if compat_res:
                     response_text = f"ğŸ¯ **CompatibilitÃ© Bac {found_b} â†’ {detected_target.capitalize()}** :\n{clean_text(compat_res[0]['Msg'])}"
                else: 
                     response_text = f"Je n'ai pas de donnÃ©e exacte pour Bac {found_b} vers {detected_target}."
            
            elif detected_target and not found_b:
                # On a la cible mais pas le Bac (ex: "Peut-on faire mÃ©decine ?")
                # On demande le Bac OU on donne les conditions gÃ©nÃ©rales
                if detected_target == 'medecine':
                    response_text = "ğŸ©º **Pour MÃ©decine** : Il faut obligatoirement un Bac Scientifique (SVT, PC, SM). Moyenne > 12."
                elif detected_target == 'ingenierie':
                     response_text = "ğŸ› ï¸ **Pour IngÃ©nieur** : Bac Scientifique ou Technique recommandÃ©. Concours ENSA/ENSAM aprÃ¨s le Bac."
                else:
                    response_text = f"ğŸ¯ **{detected_target.capitalize()}** : Quel est votre type de Bac ? (SVT, PC, Eco...)"

            elif found_b and not detected_target:
                 # On a le Bac mais pas la cible -> C'est une question d'orientation gÃ©nÃ©rale
                 pass # On laisse tomber vers le handler "Orientation par Bac" plus bas
            
            else:
                pass # Fallthrough














        # --- 6.1 STAGES & EXPERIENCES PRATIQUES ---
        elif "stage" in user_message or "stages" in user_message or "pratique" in user_message or "expÃ©rience" in user_message or "pfe" in user_message or "projet" in user_message:
            
            # Map keywords to fields
            stages_map = {
                'medecine': ['mÃ©decine', 'medecine', 'pharmacie', 'dentaire', 'santÃ©'],
                'ingenierie': ['ingÃ©nierie', 'ingenieur', 'ensa', 'emi', 'technique'],
                'informatique': ['informatique', 'info', 'it', 'data', 'cyber', 'dev'],
                'commerce': ['commerce', 'gestion', 'finance', 'marketing', 'business'],
                'shs': ['sciences humaines', 'psycho', 'socio', 'lettres'],
                'arts': ['arts', 'design', 'architecture', 'crÃ©atif'],
                'tourisme': ['tourisme', 'hÃ´tel', 'logistique']
            }
            
            found_stage = None
            for stage_key, keywords in stages_map.items():
                if any(k in user_message for k in keywords):
                    found_stage = stage_key
                    break
            
            if found_stage:
                # Query specific field
                q = f"get_stages_filiere({found_stage}, S, A)"
                res = list(prolog.query(q))
                
                if res:
                    r = res[0]
                    display_name = found_stage.capitalize()
                    if found_stage == 'medecine': display_name = 'MÃ©decine'
                    elif found_stage == 'ingenierie': display_name = 'IngÃ©nierie'
                    elif found_stage == 'shs': display_name = 'Sciences Humaines'
                    
                    response_text = f"ğŸ“ **Stages & Pratique - {display_name}** :\n"
                    response_text += f"ğŸ“‹ {clean_text(r['S'])}\n"
                    response_text += f"{clean_text(r['A'])}\n"
                else:
                    response_text = f"Je n'ai pas d'infos sur les stages en '{found_stage}'."
            else:
                # General advice
                response_text = "ğŸ“ **Stages & ExpÃ©riences** :\n"
                response_text += "Les stages sont essentiels dans toutes les filiÃ¨res.\n"
                response_text += "- VÃ©rifie que ton Ã©cole intÃ¨gre des stages obligatoires\n"
                response_text += "- Planifie dÃ¨s la 1Ê³áµ‰ annÃ©e pour max d'expÃ©rience\n"
                response_text += "PrÃ©cisez une filiÃ¨re pour dÃ©tails spÃ©cifiques."


        # --- 6.2 DUREE ETUDES (Courtes vs Longues) ---
        elif "Ã©tudes courtes" in user_message or "etudes courtes" in user_message or "Ã©tudes longues" in user_message or "etudes longues" in user_message or ("courte" in user_message and "longue" in user_message) or "bts" in user_message or "dut" in user_message or "combien d'annÃ©es" in user_message or "durÃ©e" in user_message or "duree" in user_message:
            
            # Detect which type
            if "courte" in user_message or "bts" in user_message or "dut" in user_message or "rapide" in user_message:
                found_duree = 'courtes'
            elif "longue" in user_message or "master" in user_message or "doctorat" in user_message:
                found_duree = 'longues'
            else:
                found_duree = None
            
            if found_duree:
                # Query specific duration type
                q = f"get_duree_etudes({found_duree}, D, A, I, C)"
                res = list(prolog.query(q))
                
                if res:
                    r = res[0]
                    display_name = "Ã‰tudes Courtes" if found_duree == 'courtes' else "Ã‰tudes Longues"
                    
                    response_text = f"â±ï¸ **{display_name}** :\n"
                    response_text += f"ğŸ“Œ {clean_text(r['D'])}\n"
                    response_text += f"{clean_text(r['A'])}\n"
                    response_text += f"{clean_text(r['I'])}\n"
                    response_text += f"{clean_text(r['C'])}\n"
                else:
                    response_text = f"Je n'ai pas d'infos sur les Ã©tudes '{found_duree}'."
            else:
                # General comparison
                response_text = "â±ï¸ **DurÃ©e des Ã‰tudes** :\n"
                response_text += "- **Courtes (2-3 ans)** : BTS, DUT, Licence â†’ Insertion rapide\n"
                response_text += "- **Longues (5-8 ans)** : IngÃ©nieur, MÃ©decine, Master â†’ SpÃ©cialisation\n"
                response_text += "PrÃ©cisez 'courtes' ou 'longues' pour plus de dÃ©tails."


        # --- 6.3 CONCOURS & EXAMENS D'ADMISSION (Nouveau) ---
        elif "concours" in user_message or "examen" in user_message or "admission" in user_message or "test" in user_message or "entretien" in user_message:
            
            # Map keywords to exam types
            concours_map = {
                'medecine': ['mÃ©decine', 'medecine', 'pharmacie', 'dentaire'],
                'ingenierie_public': ['ingÃ©nierie', 'ingenieur', 'ensa', 'emi', 'ensias', 'public'],
                'ecoles_privees': ['privÃ©', 'prive', 'emsi', 'uir', 'um6p', 'hem'],
                'commerce': ['commerce', 'gestion', 'encg', 'iscae', 'esca', 'business']
            }
            
            found_concours = None
            for conc_key, keywords in concours_map.items():
                if any(k in user_message for k in keywords):
                    found_concours = conc_key
                    break
            
            if found_concours:
                # Query specific exam type
                q = f"get_concours_admission({found_concours}, E, C)"
                res = list(prolog.query(q))
                
                if res:
                    r = res[0]
                    display_name = found_concours.replace('_', ' ').title()
                    if found_concours == 'medecine': display_name = 'MÃ©decine'
                    elif found_concours == 'ingenierie_public': display_name = 'IngÃ©nierie (Public)'
                    elif found_concours == 'ecoles_privees': display_name = 'Ã‰coles PrivÃ©es'
                    
                    response_text = f"ğŸ“ **Concours {display_name}** :\n"
                    response_text += f"ğŸ“‹ {clean_text(r['E'])}\n"
                    response_text += f"{clean_text(r['C'])}\n"
                else:
                    response_text = f"Je n'ai pas d'infos sur les concours '{found_concours}'."
            else:
                # General exam advice
                response_text = "ğŸ“ **Concours & Admissions** :\n"
                response_text += "- **MÃ©decine** : Dossier + concours Ã©crit/oral\n"
                response_text += "- **IngÃ©nierie** : Tests maths, physique, logique\n"
                response_text += "- **PrivÃ©** : Tests + entretien motivationnel\n"
                response_text += "- **Commerce** : Tests aptitude + Ã©tude de cas\n"
                response_text += "PrÃ©cisez une filiÃ¨re pour plus de dÃ©tails."

        # --- 6.4 CHOIX DE LANGUE (Nouveau) ---
        elif "langue" in user_message or "franÃ§ais" in user_message or "anglais" in user_message or "arabe" in user_message or "continuer en" in user_message:
            
            # Detect which language is being asked about
            langues_map = {
                'arabe': ['arabe', 'arabic', 'ar '],  # Space after 'ar' to avoid matching 'carriÃ¨re'
                'francais': ['franÃ§ais', 'francais', 'french'],
                'anglais': ['anglais', 'english']
            }
            
            found_langue = None
            for lang_key, keywords in langues_map.items():
                if any(k in user_message for k in keywords):
                    found_langue = lang_key
                    break
            
            if found_langue:
                # Query specific language
                q = f"get_choix_langue({found_langue}, D, A, I, C)"
                res = list(prolog.query(q))
                
                if res:
                    r = res[0]
                    display_name = found_langue.capitalize()
                    if found_langue == 'francais': display_name = 'FranÃ§ais'
                    elif found_langue == 'anglais': display_name = 'Anglais'
                    
                    response_text = f"ğŸŒ **Continuer en {display_name}** :\n"
                    response_text += f"ğŸ“Œ {clean_text(r['D'])}\n"
                    response_text += f"{clean_text(r['A'])}\n"
                    response_text += f"{clean_text(r['I'])}\n"
                    response_text += f"{clean_text(r['C'])}\n"
                else:
                    response_text = f"Je n'ai pas d'infos sur la langue '{found_langue}'."
            else:
                # General language advice
                response_text = "ğŸŒ **Choix de Langue** :\n"
                response_text += "- **FranÃ§ais** : Sciences, MÃ©decine, IngÃ©nierie\n"
                response_text += "- **Anglais** : IT, Commerce International\n"
                response_text += "- **Arabe** : Lettres, Droit, Sciences Humaines\n"
                response_text += "PrÃ©cisez une langue pour plus de dÃ©tails."


        # --- 6.4.BIS FINANCEMENT & BOURSES (Nouveau) ---
        elif "bourse" in user_message or "financement" in user_message or "aide" in user_message or "prÃªt" in user_message or "logement" in user_message or "coÃ»t" in user_message or "payer" in user_message:
            # Note: "coÃ»t" et "payer" peuvent matcher Ecoles PrivÃ©es (section 6), mais ici on capture les questions gÃ©nÃ©riques ou spÃ©cifiques bourses
            
            # Map keywords
            financement_map = {
                'public': ['public', 'gratuit', 'fac'],
                'bourses_gouvernementales': ['bourse', 'minhaty', 'gouvernement'],
                'bourses_privees': ['privÃ©', 'prive', 'fondation', 'mÃ©rite'],
                'international': ['Ã©tranger', 'etranger', 'erasmus', 'internationale'],
                'personnel': ['prÃªt', 'banque', 'travail', 'job']
            }
            
            found_fin = None
            for key, keywords in financement_map.items():
                if any(k in user_message for k in keywords):
                    found_fin = key
                    break
            
            # Default to bourses if just "bourse" is asked
            if not found_fin and "bourse" in user_message:
                found_fin = 'bourses_gouvernementales'

            if found_fin:
                q = f"get_financement({found_fin}, D, C)"
                res = list(prolog.query(q))
                if res:
                    r = res[0]
                    display_name = found_fin.replace('_', ' ').title()
                    response_text = f"ğŸ’° **Financement : {display_name}**\nğŸ“Œ {clean_text(r['D'])}\nğŸ’¡ {clean_text(r['C'])}"
                else: 
                     response_text = f"Pas d'info financement pour '{found_fin}'."
            else:
                 # Si on n'a pas dÃ©tectÃ© de type prÃ©cis mais que le mot clÃ© financement est lÃ 
                 # On ne fait rien si c'Ã©tait "aide" (dÃ©jÃ  gÃ©rÃ© par Vague) ou "coÃ»t" (gÃ©rÃ© par Ecoles)
                 # Sauf si on est ici, c'est que les sections prÃ©cÃ©dentes n'ont pas matchÃ© (ordre important)
                 # On renvoie un conseil gÃ©nÃ©ral
                 q = f"get_financement(bourses_gouvernementales, D, C)"
                 res = list(prolog.query(q))
                 if res:
                     r = res[0]
                     response_text = f"ğŸ’° **Bourses & Aides** :\nLa plupart des Ã©tudiants demandent **Minhaty**.\nğŸ“Œ {clean_text(r['D'])}\nğŸ’¡ PrÃ©cisez 'bourse public', 'prÃªt' ou 'Ã©tranger' pour plus de dÃ©tails."

        # --- 6.4.TER DEFINITIONS (Nouveau) ---
        elif "c'est quoi" in user_message or "dÃ©finition" in user_message or "signifie" in user_message or "c est quoi" in user_message or "cest quoi" in user_message or "qu'est ce que" in user_message or "quest ce que" in user_message:
             
             def_map = {
                 'lmd': 'LMD', 'cpge': 'CPGE', 'prepa': 'CPGE', 'bts': 'BTS', 'dut': 'DUT',
                 'ensa': 'ENSA', 'encg': 'ENCG', 'est': 'EST', 'fst': 'FST', 'ofppt': 'OFPPT',
                 'master': 'Master', 'ingÃ©nieur': 'IngÃ©nieur', 'ingenieur': 'IngÃ©nieur'
             }
             

             found_key = None
             for k, v in def_map.items():
                 # Use regex for word boundary to avoid "est" matching "c'est"
                 if re.search(rf'\b{re.escape(k)}\b', user_message):
                     found_key = v
                     break
            
             if found_key:
                 q = f"definition('{found_key}', T)"
                 res = list(prolog.query(q))
                 if res:
                     response_text = f"ğŸ“– **DÃ©finition ({found_key})** :\n{clean_text(res[0]['T'])}"
                 else:
                     response_text = f"Je n'ai pas de dÃ©finition pour '{found_key}'."
             else:
                 response_text = "ğŸ“– **DÃ©finitions** : Je peux dÃ©finir LMD, CPGE, ENSA, ENCG, EST, FST, BTS, DUT..."

        # --- 6.5 DOMAINES & DEBOUCHES (Nouveau) ---
        elif "dÃ©bouchÃ©" in user_message or "dÃ©bouchÃ©s" in user_message or "mÃ©tier" in user_message or "carriÃ¨re" in user_message or "profession" in user_message or "travailler" in user_message:
            
            # Map keywords to domain atoms
            domaines_map = {
                'medecine': ['mÃ©decine', 'medecine', 'pharmacie', 'dentaire', 'santÃ©', 'docteur'],
                'ingenierie': ['ingÃ©nierie', 'ingenieur', 'ensa', 'emi', 'gÃ©nie'],
                'informatique': ['informatique', 'info', 'it', 'data', 'cyber', 'dÃ©veloppeur', 'programmation'],
                'commerce': ['commerce', 'gestion', 'finance', 'marketing', 'business', 'encg'],
                'shs': ['sciences humaines', 'psycho', 'socio', 'journalisme', 'communication', 'lettres'],
                'archi': ['architecture', 'design', 'urbanisme', 'architecte'],
                'tourisme': ['tourisme', 'hÃ´tel', 'logistique', 'Ã©vÃ©nementiel']
            }
            
            found_domaine = None
            for dom_key, keywords in domaines_map.items():
                if any(k in user_message for k in keywords):
                    found_domaine = dom_key
                    break
            
            if found_domaine:
                # Query Prolog for domain details
                q = f"get_detail_domaine({found_domaine}, M, E, C)"
                res = list(prolog.query(q))
                
                if res:
                    r = res[0]
                    display_name = found_domaine.replace('_', ' ').title()
                    if found_domaine == 'medecine': display_name = 'MÃ©decine & SantÃ©'
                    elif found_domaine == 'ingenierie': display_name = 'IngÃ©nierie'
                    elif found_domaine == 'informatique': display_name = 'Informatique & IT'
                    elif found_domaine == 'shs': display_name = 'Sciences Humaines & Sociales'
                    elif found_domaine == 'archi': display_name = 'Architecture & Design'
                    
                    response_text = f"ğŸ’¼ **{display_name}** :\n"
                    response_text += f"ğŸ‘” **MÃ©tiers** : {clean_text(r['M'])}\n"
                    response_text += f"ğŸ« **Ã‰coles** : {clean_text(r['E'])}\n"
                    response_text += f"{clean_text(r['C'])}\n"
                    
                    # NOUVEAU: Check compatibility if Bac is mentioned
                    bacs_keywords = {
                        'SM': ['sm', 'math'],
                        'PC': ['pc', 'physique'],
                        'SVT': ['svt', 'bio'],
                        'ECO': ['eco', 'economie'],
                        'LITT': ['litt', 'lettre']
                    }
                    detected_bac = None
                    for bac_code, keywords in bacs_keywords.items():
                        if any(k in user_message for k in keywords):
                            detected_bac = bac_code
                            break
                    
                    if detected_bac:
                        # Map domain to compatibility atom
                        compat_domain_map = {
                            'medecine': 'medecine',
                            'ingenierie': 'ingenierie',
                            'informatique': 'informatique',
                            'commerce': 'commerce',
                            'shs': 'lettres',  # SHS maps to lettres in compatibility
                            'arts': 'lettres',
                            'tourisme': 'commerce'
                        }
                        compat_atom = compat_domain_map.get(found_domaine, found_domaine)
                        
                        # Check compatibility
                        q_compat = f"check_compatibilite('{detected_bac}', {compat_atom}, Statut, Msg)"
                        compat_res = list(prolog.query(q_compat))
                        if compat_res:
                            response_text += f"\n\nğŸ¯ **CompatibilitÃ© Bac {detected_bac}** :\n{clean_text(compat_res[0]['Msg'])}"
                
                else:
                    response_text = f"Je n'ai pas de dÃ©tails sur le domaine '{found_domaine}'."
            
            else:
                # Si PAS DE DOMAINE detectÃ©, on regarde si un BAC est mentionnÃ© (ex: "DÃ©bouchÃ©s SM ?")
                bacs_keywords_only = {
                    'SM': ['sm', 'math'], 'PC': ['pc', 'physique'], 'SVT': ['svt', 'bio', 'science'],
                    'ECO': ['eco', 'economie', 'gestion'], 'LITT': ['litt', 'lettre'], 'TECH': ['tech', 'meca', 'elec']
                }
                detected_bac_only = None
                for bac_code, keywords in bacs_keywords_only.items():
                   if any(k in user_message for k in keywords):
                       detected_bac_only = bac_code
                       break
                
                if detected_bac_only:
                    q_bac = f"get_detail_bac('{detected_bac_only}', I, A, L, C)"
                    res_bac = list(prolog.query(q_bac))
                    if res_bac:
                        r = res_bac[0]
                        response_text = f"ğŸ“ **DÃ©bouchÃ©s Bac {detected_bac_only}** :\n"
                        response_text += f"ğŸš€ **FiliÃ¨res** : {clean_text(r['I'])}\n"
                        response_text += f"âœ… **Avantages** : {clean_text(r['A'])}\n"
                        response_text += f"ğŸ’¡ **Conseil** : {clean_text(r['C'])}"
                    else:
                        response_text = f"Je n'ai pas d'infos dÃ©taillÃ©es pour le Bac {detected_bac_only}."
                else:
                    response_text = "ğŸ’¼ **DÃ©bouchÃ©s** : PrÃ©cisez un domaine (MÃ©decine, IngÃ©nierie) ou votre Bac (SM, PC, Eco)."

        # --- 6.5 COMPATIBILITE BAC-FILIERE (Question type "SVT + informatique possible?") ---
        # --- Section Removed: merged into 5. COMPATIBILITE ---

        # --- 6.9 NEW KNOWLEDGE: RECHERCHE PAR BAC (Support Ã‰tendu via filiere/6) ---
        elif "bac" in user_message and any(s in user_message for s in ['math', 'science', 'eco', 'lettre', 'technique', 'art', 'sm', 'pc', 'svt']):
            # Mappage des noms de bac vers les atomes Prolog du nouveau fichier
            # On utilise le mÃªme mapping regex que plus bas pour la cohÃ©rence

            bac_map_new = {
                'Sciences mathÃ©matiques A': [r'\bsm\b', r'\bmath\b'],
                'Sciences physiques': [r'\bpc\b', r'\bphysique\b'],
                'Sciences de la Vie et de la Terre': [r'\bsvt\b', r'\bbio\b', r'\bscience vie\b'],
                'Sciences Ã©conomiques': [r'\beco\b', r'\beconomie\b'],
                'Sciences de gestion comptable': [r'\bgestion\b'],
                'Sciences et technologies Ã©lectriques': [r'\belec\b', r'\btech\b'],
                'Sciences et technologies mÃ©caniques': [r'\bmeca\b', r'\bindustriel\b'],
                'Arts appliquÃ©s': [r'\bart\b', r'\barts\b', r'\bappliques\b', r'\bappliquÃ©s\b'],
                'Lettres': [r'\blitt\b', r'\blettre\b'],
                'Sciences humaines': [r'\bhumaine\b']
            }
            
            found_bac_full = None
            for name, patterns in bac_map_new.items():
                for pat in patterns:
                     if re.search(pat, user_message, re.IGNORECASE):
                         found_bac_full = name
                         break
                if found_bac_full: break
            
            if found_bac_full:
                # Query filiere/6: filiere(Bac, Secteur, Filiere, Etablissement, Duree, Diplome)
                q = f"filiere('{found_bac_full}', Secteur, Fil, Etab, Duree, Dip)"
                try:
                    res = list(prolog.query(q))
                    if res:
                        # On groupe par secteur pour l'affichage
                        secteurs = {}
                        for r in res:
                            sec = clean_text(r['Secteur'])
                            if sec not in secteurs: secteurs[sec] = []
                            # Avoid duplicates
                            entry = f"- {clean_text(r['Fil'])} ({clean_text(r['Etab'])})"
                            if entry not in secteurs[sec]:
                                secteurs[sec].append(entry)
                        
                        response_text = f"ğŸ“ **Options pour {found_bac_full}** :\n"
                        # Afficher max 3 secteurs pour ne pas spammer, ou tout? Tout c'est mieux si pas trop long.
                        for i, (sec, options) in enumerate(secteurs.items()):
                            if i > 5: break # Limit to 5 sectors
                            response_text += f"\nğŸ“‚ **{sec}** :\n" + "\n".join(options[:4]) # Max 4 per sector
                        
                        response_text += "\n\n(Dites 'DÃ©tails [FiliÃ¨re]' pour plus d'infos)"
                    else:
                        # Fallback to legacy section
                        response_text = None 
                except Exception as e:
                    print(f"Error querying filiere: {e}")
                    response_text = None
            else:
                response_text = None

        # --- 6.95 NEW KNOWLEDGE: PLATEFORMES ---
        elif "plateforme" in user_message or "site" in user_message:
             q_all = "plateforme(Nom, URL)"
             found_lat = None
             try:
                 all_plats = list(prolog.query(q_all))
                 for p in all_plats:
                     nom = clean_text(p['Nom']).lower()
                     if nom in user_message:
                         found_lat = p
                         break
                 
                 if found_lat:
                     response_text = f"ğŸ”— **Plateforme {clean_text(found_lat['Nom'])}** : {clean_text(found_lat['URL'])}"
                 else:
                     response_text = None # Let fallback handle general site queries
             except:
                 response_text = None


        if 'response_text' in locals() and response_text:
             pass # We found a response in the new logic
        else:
             # Fallback to existing logic below
             pass

        # --- 7. ORIENTATION PAR BAC (Generic & DÃ©taillÃ©) ---
        if not ('response_text' in locals() and response_text) and ("bac" in user_message or "recommander" in user_message or "faire" in user_message or "orientation" in user_message or "choisir" in user_message):
            # Ex: "bac pc", "bac sm"
            # Utilisation de Regex pour Ã©viter les faux positifs (ex: 'es' dans 'appliques')

            bacs_map = {
                'SM': [r'\bsm\b', r'\bmath\b', r'\bmaths\b'],
                'PC': [r'\bpc\b', r'\bphysique\b', r'\bchimie\b'],
                'SVT': [r'\bsvt\b', r'\bscience vie\b', r'\bbio\b'],
                'ECO': [r'\beco\b', r'\beconomie\b', r'\bgestion\b'], # 'es' removed as it's too dangerous
                'LITT': [r'\blitt\b', r'\blettre\b', r'\blettres\b', r'\bhumanitÃ©\b'],
                'TECH': [r'\btech\b', r'\btechnique\b', r'\belec\b', r'\bmeca\b', r'\bindustriel\b'],
                'ART': [r'\bart\b', r'\barts\b', r'\bappliques\b', r'\bappliquÃ©s\b']
            }
            
            user_bac = None
            for code, patterns in bacs_map.items():
                for pattern in patterns:
                    if re.search(pattern, user_message, re.IGNORECASE):
                        user_bac = code
                        break
                if user_bac: break
            
            if user_bac:
                # 1. Chercher le Profil DÃ©taillÃ©
                q_detail = f"get_detail_bac('{user_bac}', I, A, L, C)"
                res_detail = list(prolog.query(q_detail))
                
                if res_detail:
                    d = res_detail[0]
                    response_text = f"ğŸ“ **Profil BAC {user_bac}** :\n"
                    response_text += f"ğŸŒŸ **FiliÃ¨res IdÃ©ales** : {clean_text(d['I'])}\n"
                    response_text += f"{clean_text(d['A'])}\n"
                    response_text += f"{clean_text(d['L'])}\n"
                    response_text += f"{clean_text(d['C'])}\n"
                
                # Check Note if present for nuance (Logic conservÃ©e)

                match_note = re.search(r'\b(1[0-9]|20|[0-9])\b', user_message)
                if match_note:
                    note = float(match_note.group(1))
                    if note >= 15: response_text += "\nğŸŒŸ **Note > 15 : Les portes de l'Excellence (MÃ©decine, PrÃ©pa...) sont grandes ouvertes !**"
                    elif note < 12: response_text += "\nâš ï¸ **Note Juste : Assurez vos arriÃ¨res avec des concours plus accessibles ou le privÃ©.**"

                # 2. (Optionnel) Ajouter les recommandations spÃ©cifiques si le user a demandÃ© "recommander" exmplicitement ? 
                # Le profil dÃ©taillÃ© est dÃ©jÃ  trÃ¨s riche. On garde la liste simple en complÃ©ment si pas de dÃ©tail trouvÃ©?
                # Non, si on a trouvÃ© le dÃ©tail, c'est suffisant et mieux structurÃ©.
                
                if not res_detail:
                     # Fallback Old Logic
                     q = f"recommander_orientation('{user_bac}', Domaine, Ecole)"
                     results = list(prolog.query(q))
                     if results:
                        response_text = f"ğŸ“ Avec un **BAC {user_bac}**, voici des pistes :\n"
                        done = set()
                        for res in results:
                            d = clean_text(res['Domaine'])
                            e = clean_text(res['Ecole'])
                            line = f"- {d} (via {e})"
                            if line not in done:
                                response_text += line + "\n"
                                done.add(line)
            else:
                 response_text = "ğŸ“ **Orientation** : PrÃ©cisez votre Bac (PC, SM, SVT, Eco...) pour des conseils ciblÃ©s." 

        # --- 8. INFOS PRATIQUES & OUTILS (Nouveau) ---
        
        # 8.1. Seuils & Dates
        elif "seuil" in user_message or "date" in user_message or "quand" in user_message and ("concours" in user_message or "inscription" in user_message):
             keywords_map = {
                 'ensa': 'Concours ENSA', 'encg': 'Concours ENCG (TAFEM)', 'medecine': 'Concours Medecine', 'mÃ©decine': 'Concours Medecine',
                 'fst': 'Inscription CursusSup', 'est': 'Inscription CursusSup', 'cursussup': 'Inscription CursusSup', 'ofppt': 'Inscription OFPPT',
                 'bac': 'Resultats Bac'
             }
             found = None
             for k, v in keywords_map.items():
                 if k in user_message: found = v; break
            
             if found:
                 # Check Date
                 q_date = f"get_date_concours('{found}', D)"
                 res_d = list(prolog.query(q_date))
                 date_txt = clean_text(res_d[0]['D']) if res_d else "Non dÃ©fini"
                 
                 # Check Seuil (Only for schools key, tricky map reuse)
                 # We need school name for seuil: 'ENSA' not 'Concours ENSA'.
                 seuil_txt = ""
                 if "ENSA" in found: school="ENSA"
                 elif "ENCG" in found: school="ENCG"
                 elif "Medecine" in found: school="Medecine"
                 elif "FST" in user_message.upper(): school="FST" # Fallback checks
                 elif "EST" in user_message.upper(): school="EST"
                 else: school=None
                 
                 if school:
                     q_seuil = f"get_seuil('{school}', 2023, N)"
                     res_s = list(prolog.query(q_seuil))
                     if res_s: seuil_txt = f"\nğŸ“‰ **Seuil 2023** : {clean_text(res_s[0]['N'])}/20"
                 
                 response_text = f"ğŸ“… **{found}** :\nğŸ—“ï¸ **Date** : {date_txt}{seuil_txt}"
             else:
                 response_text = "ğŸ“… **Calendrier** : Je connais les dates pour ENSA, ENCG, MÃ©decine, CursusSup..."

        # 8.2. Liens & Sites
        elif "lien" in user_message or "site" in user_message or "adresse" in user_message:
             keys = {'cursussup': 'CursusSup', 'minhaty': 'Minhaty (Bourse)', 'ensa': 'ENSA Maroc', 'tafem': 'TAFEM (ENCG)', 'ofppt': 'OFPPT'}
             found = None
             for k, v in keys.items():
                 if k in user_message: found = v; break
             
             if found:
                 q = f"get_lien('{found}', U)"
                 res = list(prolog.query(q))
                 url = clean_text(res[0]['U']) if res else "#"
                 response_text = f"ğŸ”— **Lien {found}** : [Cliquez ici]({url})"
             else:
                 response_text = "ğŸ”— **Liens Utiles** : Demandez-moi CursusSup, Minhaty, ENSA..."

        # 8.3. ProcÃ©dures & Logement
        elif "comment" in user_message or "inscription" in user_message or "papier" in user_message or "document" in user_message or "logement" in user_message or "citÃ©" in user_message or "internat" in user_message:
            # Check Logement
            if "logement" in user_message or "citÃ©" in user_message or "internat" in user_message:
                type_log = 'CitÃ© Universitaire' # Default
                if "privÃ©" in user_message or "location" in user_message: type_log = 'Location PrivÃ©e'
                elif "internat" in user_message: type_log = 'Internat'
                
                q = f"get_logement('{type_log}', D, C)"
                res = list(prolog.query(q))
                if res:
                     response_text = f"ğŸ  **{type_log}** :\nâ„¹ï¸ {clean_text(res[0]['D'])}\nğŸ’¡ {clean_text(res[0]['C'])}"
                else:
                     response_text = "ğŸ  **Logement** : PrÃ©cisez CitÃ©, Internat ou Location."
            else:
                # ProcÃ©dures
                proc = 'Inscription Fac' # Default
                if "minhaty" in user_message or "bourse" in user_message: proc = 'Dossier Minhaty'
                elif "legalis" in user_message: proc = 'Legalisation'
                
                q = f"get_procedure('{proc}', D)"
                res = list(prolog.query(q))
                if res:
                     response_text = f"ğŸ“ **ProcÃ©dure {proc}** :\n{clean_text(res[0]['D'])}"

        # 8.4. OFPPT
        elif "ofppt" in user_message or "technicien" in user_message or "ista" in user_message:
             niveau = 'Technicien SpÃ©cialisÃ©'
             if "qualif" in user_message: niveau = 'Qualification'
             elif "technicien" in user_message and "spÃ©cialisÃ©" not in user_message: niveau = 'Technicien'
             
             q = f"get_formation_pro('{niveau}', D, C)"
             res = list(prolog.query(q))
             if res:
                  response_text = f"ğŸ­ **OFPPT ({niveau})** :\nâ„¹ï¸ {clean_text(res[0]['D'])}\nğŸ’¡ {clean_text(res[0]['C'])}"

        # 8.5. Calculateur de Note
        elif "calcul" in user_message or "moyenne" in user_message or "score" in user_message:

             # Extract numbers like 14.5 or 14
             nums = re.findall(r'\b\d+[.,]?\d*\b', user_message)
             nums = [float(n.replace(',', '.')) for n in nums]
             
             if len(nums) >= 2:
                  reg = nums[0]
                  nat = nums[1]
                  if reg <= 20 and nat <= 20:
                      score = (reg * 0.25) + (nat * 0.75)
                      response_text = f"ğŸ§® **Calculateur de Seuil** :\n- RÃ©gional (25%) : {reg}\n- National (75%) : {nat}\n\nâœ¨ **Votre Score d'Admission : {score:.2f}/20**\n"
                      
                      if score >= 15: response_text += "ğŸŒŸ Excellent ! Vous Ãªtes bien parti pour MÃ©decine/ENSA."
                      elif score >= 12: response_text += "âœ… Bon score. FST et EST sont trÃ¨s jouables. ENSA possible (vÃ©rifiez seuils)."
                      else: response_text += "âš ï¸ Un peu juste pour les filiÃ¨res sÃ©lectives. Visez EST, BTS ou Fac."
                  else:
                      response_text = "âš ï¸ Les notes doivent Ãªtre sur 20."
             else:
                  response_text = "ğŸ§® **Calculateur** : Donnez-moi vos notes RÃ©gional et National (ex: 'Calcul 14 16') pour avoir votre score."

        # 8.6. Quiz Orientation (MatiÃ¨res prÃ©fÃ©rÃ©es)
        elif "quiz" in user_message or "aime" in user_message or "prÃ©fÃ¨re" in user_message or "fort en" in user_message:
             response_text = "ğŸ§  **Quiz Orientation** :\n"
             
             scores = {'ingenierie': 0, 'medecine': 0, 'commerce': 0, 'lettres': 0, 'art': 0}
             
             if "math" in user_message: scores['ingenierie'] += 2; scores['commerce'] += 1
             if "physique" in user_message: scores['ingenierie'] += 2
             if "svt" in user_message or "bio" in user_message: scores['medecine'] += 3
             if "info" in user_message or "cod" in user_message: scores['ingenierie'] += 2
             if "eco" in user_message or "gest" in user_message: scores['commerce'] += 3
             if "langue" in user_message or "fran" in user_message: scores['lettres'] += 2; scores['commerce'] += 1
             if "dessin" in user_message or "art" in user_message: scores['art'] += 3; scores['ingenierie'] += 1 # Archi
             
             best = max(scores, key=scores.get)
             if scores[best] > 0:
                  rec = ""
                  if best == 'ingenierie': rec = "Vous semblez avoir un profil **IngÃ©nieur / Tech** ! ğŸ› ï¸\nğŸ‘‰ Visez ENSA, CPGE, FST, EST."
                  elif best == 'medecine': rec = "Vous avez un profil **SantÃ© / Bio** ! ğŸ©º\nğŸ‘‰ Visez MÃ©decine, Pharmacie, ISPITS."
                  elif best == 'commerce': rec = "Vous avez un profil **Manager / Eco** ! ğŸ’¼\nğŸ‘‰ Visez ENCG, ISCAE, EST."
                  elif best == 'lettres': rec = "Vous avez un profil **LittÃ©raire / Droit** ! ğŸ“š\nğŸ‘‰ Visez Fac de Droit, Lettres, Journalisme."
                  elif best == 'art': rec = "Vous avez un profil **CrÃ©atif / Archi** ! ğŸ¨\nğŸ‘‰ Visez ENA (Archi), Beaux-Arts ou Design."
                  
                  response_text = rec + "\n\n(Dites 'DÃ©tail IngÃ©nieur' pour en savoir plus)"
             else:
                  response_text = "Dites-moi quelles matiÃ¨res vous aimez (Maths, SVT, Eco, Langues...) pour que je vous oriente !"

        # --- 3. CONSEILS (Organisation, Sommeil...) ---
        elif "conseil" in user_message or "mÃ©thode" in user_message or "methode" in user_message or "rÃ©vision" in user_message or "revision" in user_message or "travail" in user_message or "avenir" in user_message or "budget" in user_message:
            # Extraction du theme
            theme = "Organisation" # Default
            if "mÃ©thode" in user_message or "methode" in user_message: theme = "MÃ©thode"
            if "rÃ©vision" in user_message or "revision" in user_message: theme = "Examens"
            if "avenir" in user_message: theme = "Vie Pro"
            if "budget" in user_message: theme = "Budget"

            # On essaie de requeter par theme, sinon on prend tout
            all_conseils = list(prolog.query("conseil(T, Txt)"))
            
            # Filtrage python simple
            filtered = []
            print(f"DEBUG: Theme demandÃ©: {theme}")
            for c in all_conseils:
                t_raw = c['T']
                t_clean = clean_text(t_raw)
                
                # Check match sur clean ET raw (au cas oÃ¹ mojibake persiste)
                # On normalize aussi pour retirer accents potentiels
                if theme.lower() in t_clean.lower() or theme.lower() in t_raw.lower() or normalize_text(theme).lower() in normalize_text(t_clean).lower():
                    filtered.append(c)
            
            print(f"DEBUG: Filtered count: {len(filtered)}")
            
            if not filtered: 
                print("DEBUG: Fallback to all_conseils")
                filtered = all_conseils
            
            if filtered:
                shuffled = random.sample(filtered, min(3, len(filtered)))
                response_text = f"ğŸ’¡ **Conseils ({theme}) :**\n"
                for r in shuffled:
                     response_text += f"- {clean_text(r['Txt'])}\n"

        # --- 8. SIMPLES ---
        elif "pomodoro" in user_message:
            response_text = "ğŸ… **Pomodoro** : Travaille 25 min Ã  fond, puis 5 min de pause."

        # --- 9. FALLBACKS (Messages vagues, Perdu, Gibberish) ---
        elif any(keyword in user_message for keyword in ['aide', 'aidez', 'help', 'aider', 'besoin']):
            response_text = "Bien sÃ»r ! ğŸ¤ Je peux vous aider sur :\n\nğŸ“ **Orientation** : 'Que faire avec un Bac PC/SVT/Eco ?'\nğŸ« **Ã‰coles** : 'Prix EMSI', 'OÃ¹ est ENSA ?'\nğŸ’¡ **Conseils** : 'Conseils rÃ©vision', 'MÃ©thode travail'\nğŸ©º **MÃ©decine** : 'MÃ©decine avec 14 de moyenne'\nğŸ’¼ **DÃ©bouchÃ©s** : 'MÃ©tiers informatique'\n\nQuelle est votre question ?"
        
        elif any(keyword in user_message for keyword in ['perdu', 'confus', 'comprends pas', 'sais pas', 'comment faire', 'quoi faire']):
            response_text = "Pas de panique ! ğŸ§­ Je vais vous guider.\n\n**Dites-moi :**\n1. Quel est votre type de Bac ? (PC, SVT, Eco...)\n2. Quelle est votre moyenne ?\n3. Avez-vous une filiÃ¨re en tÃªte ?\n\nExemple : 'Bac SVT 14 mÃ©decine'\n\nJe vous donnerai des conseils personnalisÃ©s !"

        # Gestion du "Oui/Non/Merci" (pour Ã©viter les erreurs "trop court")
        elif user_message in ['oui', 'non', 'ok', 'merci', 'daccord', 'super', 'yep', 'non merci', 'oui merci']:
             if 'merci' in user_message or 'super' in user_message:
                 response_text = "Je vous en prie ! N'hÃ©sitez pas si vous avez d'autres questions. ğŸ˜Š"
             elif 'oui' in user_message or 'ok' in user_message:
                 response_text = "Parfait ! Que voulez-vous savoir d'autre ? (Orientation, Ecoles, Conseils...)"
             else:
                 response_text = "Compris. Avez-vous une autre question ?"

        elif len(user_message) < 4 and not any(kw in user_message for kw in ['cv', 'bac', 'pc', 'sm', 'svt', 'eco', 'it', 'fr', 'en']):
            response_text = "Je n'ai pas compris votre message (trop court). ğŸ¤”\n\nEssayez une question comme :\n- 'Que faire avec un Bac PC ?'\n- 'Prix EMSI'\n- 'Conseils rÃ©vision'\n- 'MÃ©decine avec 14'"
            
    except Exception as e:
        print(f"Prolog Error: {e}")
        response_text = "ğŸ§  Je rÃ©flÃ©chis... (Erreur interne Prolog). RÃ©essayez."

    return jsonify({
        "response": response_text
    })

if __name__ == '__main__':
    print("Serveur Python + SWI-Prolog demarrÃ© sur le port 5000")
    app.run(port=5000, debug=True)
